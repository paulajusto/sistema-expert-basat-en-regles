#!/usr/bin/env python3
"""
csv2clips.py — Generic CSV → CLIPS converter.

Usage (basic):
  python csv2clips.py input.csv -o output.clp --template-name plat --facts-name plats_db

Advanced example:
  python csv2clips.py data.csv -o data.clp \
    --template-name item --facts-name items_db \
    --strings nom,descripcio \
    --multislot tags,restriccions \
    --list-sep "," \
    --class-name Item \
    --id-slot id

What it does:
- Reads a CSV and generates a CLIPS file with:
  * (deftemplate <template-name>) with slots for each column (multislot for those you specify).
  * (deffacts <facts-name> ...) with one fact per row, mapping columns → slots.
- Sanitizes slot names and symbol values to CLIPS-friendly identifiers (lowercase, ASCII, underscores).
- You can mark some columns as STRING-type slots (quoted), some as MULTISLOT (split by a separator), and leave the rest as SYMBOL/number.
- Missing values become a configurable symbol (default "-").

Notes:
- By default, types are inferred: numeric cells become numbers; others become symbols (unless in --strings).
- If you don't want the (deftemplate ...), pass --no-template and it will only emit (deffacts ...).
"""

import argparse, csv, re, unicodedata, sys, os

def norm_symbol(s: str) -> str:
    """Normalize arbitrary text into a CLIPS-friendly symbol: lowercase ascii, underscores, no leading digits."""
    s = str(s).strip()
    s = unicodedata.normalize("NFKD", s).encode("ascii", "ignore").decode("ascii")
    s = s.lower()
    s = re.sub(r"[^a-z0-9]+", "_", s).strip("_")
    if s == "":
        s = "-"
    # Avoid leading digit (CLIPS symbols can't start with a digit when unquoted in some contexts)
    if re.match(r"^[0-9]", s):
        s = "_" + s
    return s

def norm_slot_name(s: str) -> str:
    """Slot names follow same normalization as symbols."""
    return norm_symbol(s)

def try_number(x):
    try:
        if x is None: return None
        s = str(x).strip()
        if s == "": return None
        # Allow comma as decimal separator? optional: detect and replace
        if s.count(",") == 1 and s.count(".") == 0 and re.match(r"^-?\d+,\d+$", s):
            s = s.replace(",", ".")
        v = float(s)
        if abs(v - int(v)) < 1e-9:
            return int(v)
        return v
    except Exception:
        return None

def split_multislot(cell, sep):
    if cell is None: 
        return []
    text = str(cell).strip()
    if text == "": 
        return []
    parts = [p.strip() for p in text.split(sep)]
    out = []
    for p in parts:
        if p == "": 
            continue
        out.append(norm_symbol(p))
    return out

def main():
    ap = argparse.ArgumentParser(description="Convert CSV to CLIPS (deftemplate + deffacts).")
    ap.add_argument("csv", help="Input CSV path")
    ap.add_argument("-o", "--output", required=True, help="Output .clp path")
    ap.add_argument("--template-name", default="row", help="Name of the CLIPS deftemplate (default: row)")
    ap.add_argument("--facts-name", default="rows_db", help="Name of the deffacts collection (default: rows_db)")
    ap.add_argument("--no-template", action="store_true", help="Do not emit (deftemplate ...), only (deffacts ...)")
    ap.add_argument("--strings", default="", help="Comma-separated list of columns to treat as STRING slots (quoted)")
    ap.add_argument("--multislot", default="", help="Comma-separated list of columns that are MULTISLOT (split by --list-sep)")
    ap.add_argument("--list-sep", default=",", help="Separator used inside cells for multislot columns (default: ,)")
    ap.add_argument("--id-slot", default="", help="Optional name for an auto-increment id slot (will be first slot)")
    ap.add_argument("--missing-symbol", default="-", help="Symbol to use for missing values in non-string slots (default: -)")
    ap.add_argument("--class-name", default="", help="Optional class name hint (cosmetic; not required)")

    args = ap.parse_args()

    # Parse column directives
    string_cols = set([c.strip() for c in args.strings.split(",") if c.strip() != ""])
    multislot_cols = set([c.strip() for c in args.multislot.split(",") if c.strip() != ""])

    # Read CSV header and rows
    with open(args.csv, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        columns = reader.fieldnames or []
        rows = list(reader)

    if not columns:
        print("ERROR: CSV appears to have no header.", file=sys.stderr)
        sys.exit(2)

    # Map original column names → slot names
    slot_names = [norm_slot_name(c) for c in columns]
    col_to_slot = dict(zip(columns, slot_names))

    # Build template text
    out_lines = []
    out_lines.append(";;; Auto-generated by csv2clips.py")
    out_lines.append(f";;; Source CSV: {os.path.abspath(args.csv)}")
    out_lines.append(f"(defmodule DB (export ?ALL))")
    if not args.no_template:
        out_lines.append(f"(deftemplate {args.template_name}")
        if args.id_slot:
            out_lines.append(f"  (slot {norm_slot_name(args.id_slot)})")
        for col in columns:
            slot = col_to_slot[col]
            if col in multislot_cols:
                out_lines.append(f"  (multislot {slot})")
            elif col in string_cols:
                out_lines.append(f"  (slot {slot} (type STRING))")
            else:
                out_lines.append(f"  (slot {slot})")
        out_lines.append(")")
        out_lines.append("")

    out_lines.append(f"(deffacts {args.facts_name}")

    # Emit facts
    auto_id = 1
    for row in rows:
        out_lines.append(f"  ({args.template_name}")
        if args.id_slot:
            out_lines.append(f"    ({norm_slot_name(args.id_slot)} {auto_id})")
            auto_id += 1

        for col in columns:
            slot = col_to_slot[col]
            raw = row.get(col, None)

            if col in multislot_cols:
                items = split_multislot(raw, args.list_sep)
                if items:
                    out_lines.append(f"    ({slot} {' '.join(items)})")
                else:
                    out_lines.append(f"    ({slot} )")
                continue

            if col in string_cols:
                text = "" if raw is None else str(raw).replace('"', r'\"')
                out_lines.append(f'    ({slot} "{text}")')
                continue

            # numeric or symbol (amb tractament especial per a 'dieta')
            num = try_number(raw)
            if num is not None:
                out_lines.append(f"    ({slot} {num})")
            else:
                if col.lower().strip() == "dieta":
                    # GUARDA SEMPRE COM A STRING (entre cometes, sense normalitzar)
                    text = "" if raw is None else str(raw).strip().replace('"', r'\"')
                    out_lines.append(f'    ({slot} "{text}")')
                else:
                    # Per la resta de columnes, segueix com abans
                    sym = args.missing_symbol if (raw is None or str(raw).strip() == "") else norm_symbol(raw)
                    out_lines.append(f"    ({slot} {sym})")


        out_lines.append("  )")
    out_lines.append(")")

    # Write file
    with open(args.output, "w", encoding="utf-8") as fo:
        fo.write("\n".join(out_lines))

    print(f"Wrote CLIPS to {args.output}")

if __name__ == "__main__":
    main()